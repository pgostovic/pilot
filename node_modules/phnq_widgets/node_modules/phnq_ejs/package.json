{
  "name": "phnq_ejs",
  "description": "Embedded JavaScript templating tool",
  "homepage": "https://github.com/pgostovic/phnq_ejs",
  "keywords": [
    "phnq",
    "ejs",
    "server",
    "client",
    "browser"
  ],
  "author": {
    "name": "Patrick Gostovic",
    "email": "pg@phnq.org"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/pgostovic/phnq_ejs.git"
  },
  "main": "phnq_ejs.js",
  "version": "1.0.9",
  "dependencies": {
    "phnq_log": "1.0.x",
    "phnq_core": "1.0.x",
    "mocha": "1.6.0"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "engines": {
    "node": "0.8.x"
  },
  "readme": "phnq_ejs - EJS Templates\n========================\nThe phnq_ejs module is simple templating utility that uses embedded JavaScript. It's inspired by several familiar embedded language templating systems such as ERB, JSP, ASP, etc. EJS uses the same notation as the aforementioned systems for embedding dynamic code into templates.  For example:\n\n\t<%= foo %>\n\nThis will cause the result of the statement \"foo\" to be rendered.  So, if the value of \"foo\" were \"bar\", then the following...\n\n\t<h1><%= foo %></h1>\n\n...would evaluate to:\n\n\t<h1>bar</h1>\n\nBlocks of JavaScript are embedded with the <% %> notation.  For example:\n\n\t<% for(var i=0; i<5; i++) { %>\n\t\t<div>Number <%= i %></div>\n\t<% } %>\n\nThe above code would render as follows:\n\n\t<div>Number 0</div>\n\t<div>Number 1</div>\n\t<div>Number 2</div>\n\t<div>Number 3</div>\n\t<div>Number 4</div>\n\nVery basic. Very simple.\n\nExpressions\n-----------\nAn alternate syntax, called expressions, is also available. For example:\n\n\t${foo}\n\nThis is equivalent to:\n\n\t<%= foo %>\n\nAnother example:\n\n\t{if true}\n\t\t<p>truth</p>\n\t{/if}\n\nThis is equivalent to:\n\n\t<% if(true) { %>\n\t\t<p>truth</p>\n\t<% } %>\n\nNotice the dollar sign in the ${foo} example and the lack of dollar sign in the {if} example. The syntax with the dollar sign just renders a JavaScript value.  The syntax without the dollar sign must adgere to xml-like syntax. That is, these \"tags\" must be well-formed; each open tag must have a corresponding closing tag, or they must be empty. These \"structured\" expressions are treated like functions, unless their \"tag\" name is one of if, else, while or for, in which case they are treated like control structures. For example:\n\n\t{for var i=0; i<5; i++}\n\t\t<div>Number ${i}</div>\n\t{/for}\n\nThis is a slightly more elegant way to achieve one of the previous examples.\n\n\nBasic Usage\n-----------\n\nImport the phnq_ejs module:\n\n\tvar phnq_ejs = require(\"phnq_ejs\");\n\nOr on the client just include the file.\n\nCompile your template as a string:\n\n\tvar compiled = phnq_ejs.compile(someString);\n\nThe compiled result is a string that can be eval'd to a function. For example:\n\n\tvar fn = eval(compiled);\n\nThe result of executing the function will be the template rendered into a string.\n\nExample\n-------\n\nSuppose the variable \"tmplt\" held the following string:\n\n\t<ul>\n\t\t<% for(var i=0; i<3; i++) { %>\n\t\t\t<li><%= i %></li>\n\t\t<% } %>\n\t</ul>\n\nCompile that template string as follows:\n\n\tvar compiled = phnq_ejs.compile(tmplt);\n\nTurn the compiled code into a function like this:\n\n\tvar fn = eval(compiled);\n\nRender the template by calling the function:\n\n\tvar output = fn();\n\nIn this examle, \"output\" would be the following:\n\n\t<ul>\n\t\t<li>0</li>\n\t\t<li>1</li>\n\t\t<li>2</li>\n\t</ul>\n\nParameters\n----------\n\nSuppose you have the following template in the variable \"tmplt\":\n\n\t<div>\n\t\tName: <%= user.name %><br/>\n\t\tEmail: <%= user.email %><br/>\n\t</div>\n\nWhere does the \"user\" object come from? It is not declared anywhere in the template. The answer is that information can be passed into the function that is eval's from the compiled code. For example:\n\nCompile and eval to a function:\n\n\tvar compiled = phnq_ejs.compile(tmplt);\n\tvar fn = eval(compiled);\n\nThe resulting function can optionally take a single argument, an object that represents all of the \"local\" variables that are referenced from the template.  For example:\n\n\tvar user = { name: \"Bubba Gump\", email: \"bubba@gump.com\" };\n\n\tvar output = fn({user: user});\n\nThe resulting output in this case would be:\n\n\t<div>\n\t\tName: Bubba Gump<br/>\n\t\tEmail: bubba@gump.com<br/>\n\t</div>\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/pgostovic/phnq_ejs/issues"
  },
  "_id": "phnq_ejs@1.0.9",
  "_from": "phnq_ejs@1.0.x"
}
